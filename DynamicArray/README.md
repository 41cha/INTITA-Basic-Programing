# Динамічний масив на Python: реалізація та аналіз

В рамках роботи був реалізований клас DynamicArray, який використовує модуль ctypes для створення та розширення масиву фіксованого розміру. Масив дозволяє додавати елементи, автоматично збільшуючи ємність при потребі.
Передбачено три стратегії зростання capacity:

Double: при кожному перевиділенні нова ємкість = стара * 2

Fixed: коефіцієнт = 1 + (4 / 10)

Dynamic: коефіцієнт = 1 + (4 / 10) / log2(size + 2)

Клас підтримує ручний доступ до елементів (методи get/set), ітерацію через print_all та конвертацію в список.
Висновки щодо ефективності стратегій
Double-стратегія дає меншу кількість перевиділень і більшу невикористану пам’ять, але найшвидша.

Fixed коефіцієнт зменшує втрати пам’яті, але призводить до більшої кількості resize-операцій.

Dynamic стратегія найбільш економна по пам’яті, але повільніша через часті resize.

Додавання елементів масштабується добре при великих стартових capacity та агресивному growth factor, але це шкодить ефективності використання пам’яті.

# Графіки для порівняння різних стратегій зростання

### Capacity = 8

![графік для capacity 8](images/Figure_8.png)

### Середнє невикористане місце:
| Стратегія | Resize операцій | Невикористане місце (елементів) |
| --------- | --------------- | ------------------------------- |
| double    | 14              | 31072                           |
| fixed     | 29              | 25841                           |
| dynamic   | 246             | 37                              |

### Capacity = 32

![графік для capacity 32](images/Figure_32.png)

### Середнє невикористане місце:
| Стратегія | Resize операцій | Невикористане місце (елементів) |
| --------- | --------------- | ------------------------------- |
| double    | 12              | 31072                           |
| fixed     | 25              | 36962                           |
| dynamic   | 226             | 37                              |


### Capacity = 128

![графік для capacity 128](images/Figure_128.png)

### Середнє невикористане місце:
| Стратегія | Resize операцій | Невикористане місце (елементів) |
| --------- | --------------- | ------------------------------- |
| double    | 10              | 31072                           |
| fixed     | 20              | 6173                            |
| dynamic   | 202             | 1000                            |

## Порівняння результатів

| Capacity | Стратегія | Середнє невикористане місце (елементів) | Resize операцій |
| -------- | --------- | --------------------------------------- | --------------- |
| 8        | double    | 23996.00                                | 14              |
| 8        | fixed     | 10155.72                                | 29              |
| 8        | dynamic   | 654.66                                  | 246             |
| 32       | double    | 23996.00                                | 12              |
| 32       | fixed     | 9323.05                                 | 25              |
| 32       | dynamic   | 654.66                                  | 226             |
| 128      | double    | 23996.00                                | 10              |
| 128      | fixed     | 9280.11                                 | 20              |
| 128      | dynamic   | 609.46                                  | 202             |


### Основні спостереження
Для стратегії double середнє невикористане місце завжди однакове (23996 елементів) для будь-якого capacity, тобто вона сильно перевиділяє пам’ять і майже не залежить від базової місткості.

Для fixed стратегій невикористане місце помітно менше, ніж у double, але все ще дуже велике (≈9300–10150 елементів), тож пам’ять усе одно витрачається неефективно.

dynamic стратегія показує на порядок менше невикористаного місця (≈600–650 елементів) для всіх capacity, що узгоджується з ідеєю динамічних масивів, які ростуть поступово й мінімізують «порожній» буфер.
​

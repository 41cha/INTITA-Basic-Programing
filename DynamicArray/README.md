# Динамічний масив на Python: реалізація та аналіз

В рамках роботи був реалізований клас DynamicArray, який використовує модуль ctypes для створення та розширення масиву фіксованого розміру. Масив дозволяє додавати елементи, автоматично збільшуючи ємність при потребі.
Передбачено три стратегії зростання capacity:

Double: при кожному перевиділенні нова ємкість = стара * 2

Fixed: коефіцієнт = 1 + (4 / 10)

Dynamic: коефіцієнт = 1 + (4 / 10) / log2(size + 2)

Клас підтримує ручний доступ до елементів (методи get/set), ітерацію через print_all та конвертацію в список.
Висновки щодо ефективності стратегій
Double-стратегія дає меншу кількість перевиділень і більшу невикористану пам’ять, але найшвидша.

Fixed коефіцієнт зменшує втрати пам’яті, але призводить до більшої кількості resize-операцій.

Dynamic стратегія найбільш економна по пам’яті, але повільніша через часті resize.

Додавання елементів масштабується добре при великих стартових capacity та агресивному growth factor, але це шкодить ефективності використання пам’яті.

## Графіки для порівняння різних стратегій зростання

# Capacity = 8

![графік для capacity 8](images/Figure_for_cap8.png)

| Розмір | double (мс) | fixed (мс) | dynamic (мс) |
| ------ | ----------- | ---------- | ------------ |
| 100    | 0.20        | 0.37       | 0.88         |
| 1000   | 1.36        | 2.09       | 7.29         |
| 10000  | 10.67       | 18.41      | 96.80        |
| 25000  | 22.27       | 42.17      | 273.14       |
| 50000  | 57.23       | 76.26      | 607.10       |
| 75000  | 131.71      | 114.38     | 1021.63      |
| 100000 | 124.19      | 163.64     | 1386.71      |

# Capacity = 32

![графік для capacity 32](images/Figure_for_cap32.png)

| Розмір | double (мс) | fixed (мс) | dynamic (мс) |
| ------ | ----------- | ---------- | ------------ |
| 100    | 0.13        | 0.23       | 0.66         |
| 1000   | 1.04        | 1.38       | 7.43         |
| 10000  | 11.10       | 17.40      | 103.03       |
| 25000  | 33.78       | 38.05      | 323.81       |
| 50000  | 63.14       | 98.85      | 680.05       |
| 75000  | 112.35      | 150.79     | 1025.64      |
| 100000 | 144.16      | 223.98     | 1517.61      |

# Capacity = 128

![графік для capacity 128](images/Figure_for_cap128.png)

| Розмір | double (мс) | fixed (мс) | dynamic (мс) |
| ------ | ----------- | ---------- | ------------ |
| 100    | 0.05        | 0.06       | 0.11         |
| 1000   | 0.77        | 1.40       | 7.53         |
| 10000  | 9.10        | 11.16      | 95.37        |
| 25000  | 21.70       | 33.28      | 300.90       |
| 50000  | 44.55       | 76.46      | 646.28       |
| 75000  | 82.31       | 119.75     | 972.31       |
| 100000 | 118.48      | 145.35     | 1380.18      |

## Порівняння результатів

| GW / Capacity      | 8                                       | 32                                          | 128                                                                      |
| ------------------ | --------------------------------------- | ------------------------------------------- | ------------------------------------------------------------------------ |
| double             | ОК, але неідеально для 100k (124.19 мс) | ОК, трохи гірше за 8 на 100k (144.16 мс)    | Найкращий варіант: найменший час на всіх розмірах (до 118.48 мс на 100k) |
| fixed              | Середній варіант, повільніше за double  | Середній, повільніше за double, без переваг | Середній, усе ще гірше за double                                         |
| dynamic (лінійний) | Явно найгірший, в рази повільніший      | Те саме: значно повільніший за інші         | Те саме: дуже великі часи, не варто використовувати                      |

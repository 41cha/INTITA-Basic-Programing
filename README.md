Динамічний масив на Python: реалізація та аналіз
Короткий опис реалізації
В рамках роботи був реалізований клас DynamicArray, який використовує модуль ctypes для створення та розширення масиву фіксованого розміру. Масив дозволяє додавати елементи, автоматично збільшуючи ємність при потребі.
Передбачено три стратегії зростання capacity:

Double: при кожному перевиділенні нова ємкість = стара * 2

Fixed: коефіцієнт = 1 + (4 / 10)

Dynamic: коефіцієнт = 1 + (4 / 10) / log2(size + 2)

Клас підтримує ручний доступ до елементів (методи get/set), ітерацію через print_all та конвертацію в список.
Висновки щодо ефективності стратегій
Double-стратегія дає меншу кількість перевиділень і більшу невикористану пам’ять, але найшвидша.

Fixed коефіцієнт зменшує втрати пам’яті, але призводить до більшої кількості resize-операцій.

Dynamic стратегія найбільш економна по пам’яті, але повільніша через часті resize.

Додавання елементів масштабується добре при великих стартових capacity та агресивному growth factor, але це шкодить ефективності використання пам’яті.


![графік для capacity 8](images/Figure_for_cap8.png)

for initial cap 8:

double: 100 елементів - 0.20 мс

double: 1000 елементів - 1.36 мс

double: 10000 елементів - 10.67 мс

double: 25000 елементів - 22.27 мс

double: 50000 елементів - 57.23 мс

double: 75000 елементів - 131.71 мс

double: 100000 елементів - 124.19 мс



fixed: 100 елементів - 0.37 мс

fixed: 1000 елементів - 2.09 мс

fixed: 10000 елементів - 18.41 мс

fixed: 25000 елементів - 42.17 мс

fixed: 50000 елементів - 76.26 мс

fixed: 75000 елементів - 114.38 мс

fixed: 100000 елементів - 163.64 мс



dynamic: 100 елементів - 0.88 мс

dynamic: 1000 елементів - 7.29 мс

dynamic: 10000 елементів - 96.80 мс

dynamic: 25000 елементів - 273.14 мс

dynamic: 50000 елементів - 607.10 мс

dynamic: 75000 елементів - 1021.63 мс

dynamic: 100000 елементів - 1386.71 мс



![графік для capacity 32](images/Figure_for_cap32.png)

for initial cap 32:

double: 100 елементів - 0.13 мс

double: 1000 елементів - 1.04 мс

double: 10000 елементів - 11.10 мс

double: 25000 елементів - 33.78 мс

double: 50000 елементів - 63.14 мс

double: 75000 елементів - 112.35 мс

double: 100000 елементів - 144.16 мс



fixed: 100 елементів - 0.23 мс

fixed: 1000 елементів - 1.38 мс

fixed: 10000 елементів - 17.40 мс

fixed: 25000 елементів - 38.05 мс

fixed: 50000 елементів - 98.85 мс

fixed: 75000 елементів - 150.79 мс

fixed: 100000 елементів - 223.98 мс



dynamic: 100 елементів - 0.66 мс

dynamic: 1000 елементів - 7.43 мс

dynamic: 10000 елементів - 103.03 мс

dynamic: 25000 елементів - 323.81 мс

dynamic: 50000 елементів - 680.05 мс

dynamic: 75000 елементів - 1025.64 мс

dynamic: 100000 елементів - 1517.61 мс



![графік для capacity 128](images/Figure_for_cap128.png)

for initial cap 128:

double: 100 елементів - 0.05 мс

double: 1000 елементів - 0.77 мс

double: 10000 елементів - 9.10 мс

double: 25000 елементів - 21.70 мс

double: 50000 елементів - 44.55 мс

double: 75000 елементів - 82.31 мс

double: 100000 елементів - 118.48 мс



fixed: 100 елементів - 0.06 мс

fixed: 1000 елементів - 1.40 мс

fixed: 10000 елементів - 11.16 мс

fixed: 25000 елементів - 33.28 мс

fixed: 50000 елементів - 76.46 мс

fixed: 75000 елементів - 119.75 мс

fixed: 100000 елементів - 145.35 мс



dynamic: 100 елементів - 0.11 мс

dynamic: 1000 елементів - 7.53 мс

dynamic: 10000 елементів - 95.37 мс

dynamic: 25000 елементів - 300.90 мс

dynamic: 50000 елементів - 646.28 мс

dynamic: 75000 елементів - 972.31 мс

dynamic: 100000 елементів - 1380.18 мс
